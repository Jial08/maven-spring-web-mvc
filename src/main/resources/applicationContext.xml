<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans  
                        http://www.springframework.org/schema/beans/spring-beans.xsd  
                        http://www.springframework.org/schema/mvc  
                        http://www.springframework.org/schema/mvc/spring-mvc.xsd  
                        http://www.springframework.org/schema/context  
                        http://www.springframework.org/schema/context/spring-context.xsd">
 	
 	<!-- ==================== ViewResolver ==================== -->
	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="viewClass"
			value="org.springframework.web.servlet.view.JstlView" />
		<!-- prefix和suffix：查找视图页面的前缀和后缀(前缀[逻辑视图名]后缀)，比如传进来的逻辑视图名为hello，
			 则该jsp视图页面应该存放在/WEB-INF/jsp/hello.jsp -->
		<property name="prefix" value="/WEB-INF/jsp/" />
		<property name="suffix" value=".jsp" />
	</bean>
	<!-- ==================== ViewResolver ==================== -->
	
	
	
	<!-- ==================== 注入bean的方法 ==================== -->
	
	<!-- ·········· 方法一 ·········· -->
	<bean name="/controller" class="demo.controller.TestController"/>
 	<bean name="/handler" class="demo.controller.TestHandler"/>
	<!-- ·········· 方法一 ·········· -->
	
	
	<!-- ·········· 方法二 ·········· -->
	<!-- 注入controller层，service层不需要注解，在applicationContext-service.xml配置文件中直接注入，
		  但service接口需要实现getset方法 -->
 	<bean id="demo.controller2.TestAnnotation2" class="demo.controller2.TestAnnotation2">
 		<!-- ref指service层注入后的id -->
		<property name="testService" ref="demo.service.impl.TestService2"></property>
	</bean>
	<!-- ·········· 方法二 ·········· -->
	
	
	<!-- ·········· 方法三 ·········· -->
	<!-- 注解驱动，是一种简写形式，会自动注册org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping
 		 与org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter两个bean，
 		 是springMVC为@Controllers分发请求所必须的。
 		 并提供了：数据绑定支持，@NumberFormatannotation支持，@DateTimeFormat支持，@Valid支持，读写XML的支持（JAXB），读写JSON的支持（Jackson）。 -->
 	<mvc:annotation-driven/>
 	
 	<!-- 如果使用了上面的<context:component-scan>标签，则下面的标签就不需要了，
 		 详见http://www.cnblogs.com/dreamroute/p/4493346.html -->
 	<!-- <context:annotation-config/> -->
 	
 	<!-- context:component-scan标签，有一个默认的use-default-filters属性，默认为true，有了这个标签，
 		spring可以自动去扫描demo下或子包下的java文件，如果扫描到有@Controller、@Service、@Repository
 		 等这些注解的类，并把这些类注册为bean -->
 	<!-- 另外它还有两个子标签<context:include-filter>和<context:exclude-filter>，如果use-default-filters为false，
 		 <context:exclude-filter>指定的不扫描，<context:include-filter>指定的扫描 -->
 	<!-- 关于type类型，详见http://outofmemory.cn/java/spring/spring-DI-with-annotation-context-component-scan -->
 	<context:component-scan base-package="demo" use-default-filters="false">
 		<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
 		<context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/>
 		<!-- 方法二中demo.controller2.TestAnnotation2已注入，重复注入启动会报错，所以排除掉 -->
 		<context:exclude-filter type="assignable" expression="demo.controller2.TestAnnotation2"/>
 	</context:component-scan>
	<!-- ·········· 方法三 ·········· -->
	
	<!-- ==================== 注入bean的方法 ==================== -->
 	
 	
 	
 	<!-- ==================== 加载拦截器 ==================== -->
 	
 	<!-- ·········· 方法一，BeanNameUrlHandlerMapping上的拦截 ·········· -->
 	<!-- 如果上面有声明<mvc:annotation-driven/>标签，会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter这两个bean，
 		  就没有机会再注入interceptors属性，就无法指定拦截器，所以该方法不能指定<mvc:annotation-driven/>标签-->
 	<!-- <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping">  
	    <property name="interceptors">  
		    <list>  
			    <bean class="interceptor.HandlerInterceptor1"/>
			    <bean class="interceptor.HandlerInterceptor2"/>
		    </list>  
	    </property>
	</bean> -->
	<!-- ·········· 方法一 ·········· -->
	
	
	<!-- ·········· 方法二，DefaultAnnotationHandlerMapping上的拦截 ·········· -->
	<!-- 采用折中的方法，下面的两个bean相当于<mvc:annotation-driven/>标签，具有该标签的部分功能，但是不能指定该标签。
		 而且采用这种方法后bean的第一种注入方法将失效，剩余方法的json转换也会失效，所以不建议采用这种方法。 -->
 	<!-- <bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping">
 		<property name="interceptors">
 			<list>
 				<bean class="interceptor.HandlerInterceptor1"/>
 				<bean class="interceptor.HandlerInterceptor2"/>
 			</list>
 		</property>
 	</bean>
 	<bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"/> -->
 	<!-- ·········· 方法二 ·········· -->
 	
 	
 	<!-- ·········· 方法三 ，(近似)总拦截器，拦截所有URL ··········-->
 	<!-- 说近似是因为spring没有总的拦截器。
 		 <mvc:annotation-driven/>会为每一个HandlerMapping注入一个拦截器，总有一个HandlerMapping
 		 是可以找到处理器的，最多也只找到一个处理器，所以这个拦截器总会被执行的，起到了总拦截器的作用。 -->
 	<mvc:interceptors>
 		<bean class="interceptor.HandlerInterceptor1"/>
 		<bean class="interceptor.HandlerInterceptor2"/>
 	</mvc:interceptors>
 	<!-- ·········· 方法三 ·········· -->
 	
 	
 	<!-- ·········· 方法四，拦截匹配的URL ·········· -->
 	<!-- <mvc:interceptors>
 		<mvc:interceptor>
 			<mvc:mapping path="/annotation1/*"/>
 			<bean class="interceptor.HandlerInterceptor1"/>
 		</mvc:interceptor>
 	</mvc:interceptors> -->
 	<!-- ·········· 方法四 ·········· -->
	
    <!-- ==================== 加载拦截器 ==================== -->                    
</beans>                        